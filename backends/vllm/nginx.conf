worker_processes auto;

events {
    worker_connections 1024;
}

http {
    client_max_body_size 50m;
    client_body_buffer_size 50m;

    proxy_buffering off;
    proxy_cache off;
    proxy_http_version 1.1;

    # Docker 内蔵 DNS（$backend 変数解決に必須）
    resolver 127.0.0.11 valid=30s;

    server {
        listen 8000;
        default_type application/json;

        # --- 内部サブリクエスト用 ---

        location /internal/qwen/ {
            internal;
            proxy_pass http://vllm-multi-qwen:8000/;
        }

        location /internal/nemotron/ {
            internal;
            proxy_pass http://vllm-multi-nemotron:8000/;
        }

        location = /health {
            content_by_lua_block {
                local cjson = require "cjson"
                local res1, res2 = ngx.location.capture_multi({
                    {"/internal/qwen/health"},
                    {"/internal/nemotron/health"},
                })
                local qwen_ok = res1.status == 200
                local nemotron_ok = res2.status == 200
                ngx.header["Content-Type"] = "application/json"
                if qwen_ok and nemotron_ok then
                    ngx.say(cjson.encode({
                        status = "healthy",
                        backends = { qwen = "healthy", nemotron = "healthy" }
                    }))
                else
                    ngx.status = 503
                    ngx.say(cjson.encode({
                        status = "unhealthy",
                        backends = {
                            qwen = qwen_ok and "healthy" or ("unhealthy:" .. tostring(res1.status)),
                            nemotron = nemotron_ok and "healthy" or ("unhealthy:" .. tostring(res2.status)),
                        }
                    }))
                end
            }
        }

        location = /v1/models {
            content_by_lua_block {
                local cjson = require "cjson"
                local res1, res2 = ngx.location.capture_multi({
                    {"/internal/qwen/v1/models"},
                    {"/internal/nemotron/v1/models"},
                })
                local models = {}
                local errors = {}
                for i, res in ipairs({res1, res2}) do
                    local name = (i == 1) and "qwen" or "nemotron"
                    if res.status == 200 then
                        local ok, data = pcall(cjson.decode, res.body)
                        if ok and data.data then
                            for _, m in ipairs(data.data) do
                                models[#models + 1] = m
                            end
                        else
                            ngx.log(ngx.ERR, "failed to parse models response from " .. name)
                            errors[#errors + 1] = name
                        end
                    else
                        ngx.log(ngx.ERR, name .. " returned status " .. tostring(res.status))
                        errors[#errors + 1] = name
                    end
                end
                ngx.header["Content-Type"] = "application/json"
                if #models == 0 and #errors > 0 then
                    ngx.status = 503
                    ngx.say(cjson.encode({
                        object = "list",
                        data = {},
                        error = { message = "backends unavailable: " .. table.concat(errors, ", ") }
                    }))
                else
                    ngx.say(cjson.encode({object = "list", data = models}))
                end
            }
        }

        # --- /v1/* API: リクエストボディの model フィールドでルーティング ---

        location /v1/ {
            set $backend "";

            access_by_lua_block {
                local cjson = require "cjson"
                ngx.req.read_body()
                local body = ngx.req.get_body_data()

                -- client_body_buffer_size を超えた場合、テンポラリファイルから読み取り
                if not body then
                    local file = ngx.req.get_body_file()
                    if file then
                        local f = io.open(file, "r")
                        if f then
                            body = f:read("*a")
                            f:close()
                        end
                    end
                end

                if not body or body == "" then
                    ngx.status = 400
                    ngx.header["Content-Type"] = "application/json"
                    ngx.say(cjson.encode({
                        error = {
                            message = "request body is required with a 'model' field",
                            type = "invalid_request_error",
                        }
                    }))
                    return ngx.exit(400)
                end

                local ok, data = pcall(cjson.decode, body)
                if not ok then
                    ngx.status = 400
                    ngx.header["Content-Type"] = "application/json"
                    ngx.say(cjson.encode({
                        error = {
                            message = "invalid JSON in request body",
                            type = "invalid_request_error",
                        }
                    }))
                    return ngx.exit(400)
                end

                if not data.model or type(data.model) ~= "string" then
                    ngx.status = 400
                    ngx.header["Content-Type"] = "application/json"
                    ngx.say(cjson.encode({
                        error = {
                            message = "'model' field is required and must be a string",
                            type = "invalid_request_error",
                        }
                    }))
                    return ngx.exit(400)
                end

                local model = string.lower(data.model)
                if string.find(model, "qwen", 1, true) then
                    ngx.var.backend = "vllm-multi-qwen"
                elseif string.find(model, "nemotron", 1, true) then
                    ngx.var.backend = "vllm-multi-nemotron"
                else
                    ngx.status = 404
                    ngx.header["Content-Type"] = "application/json"
                    ngx.say(cjson.encode({
                        error = {
                            message = "unknown model: " .. data.model,
                            type = "invalid_request_error",
                        }
                    }))
                    return ngx.exit(404)
                end
            }

            proxy_pass http://$backend:8000;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header Connection '';
            chunked_transfer_encoding off;
            proxy_connect_timeout 10s;
            proxy_read_timeout 300s;
            proxy_send_timeout 60s;
        }

        # バックエンド障害時に JSON エラーレスポンスを返す
        location @upstream_error {
            internal;
            content_by_lua_block {
                local cjson = require "cjson"
                ngx.header["Content-Type"] = "application/json"
                ngx.say(cjson.encode({
                    error = {
                        message = "backend server unavailable, please retry later",
                        type = "server_error",
                    }
                }))
            }
        }

        error_page 502 503 504 = @upstream_error;
    }
}
