worker_processes auto;

events {
    worker_connections 1024;
}

http {
    client_max_body_size 50m;
    client_body_buffer_size 10m;

    proxy_buffering off;
    proxy_cache off;
    proxy_http_version 1.1;

    # Docker 内蔵 DNS（$backend 変数解決に必須）
    resolver 127.0.0.11 valid=30s;

    server {
        listen 8000;

        # --- 内部サブリクエスト用 ---

        location /internal/qwen/ {
            internal;
            proxy_pass http://trtllm-multi-qwen:8000/;
        }

        location /internal/nemotron/ {
            internal;
            proxy_pass http://trtllm-multi-nemotron:8000/;
        }

        # --- ヘルスチェック: 両バックエンドが正常なら 200 ---

        location = /health {
            content_by_lua_block {
                local res1, res2 = ngx.location.capture_multi({
                    {"/internal/qwen/health"},
                    {"/internal/nemotron/health"},
                })
                ngx.header["Content-Type"] = "application/json"
                if res1.status == 200 and res2.status == 200 then
                    ngx.say('{"status":"healthy"}')
                else
                    ngx.status = 503
                    ngx.say('{"status":"unhealthy"}')
                end
            }
        }

        # --- /v1/models: 両バックエンドのモデル一覧を集約 ---

        location = /v1/models {
            content_by_lua_block {
                local cjson = require "cjson"
                local res1, res2 = ngx.location.capture_multi({
                    {"/internal/qwen/v1/models"},
                    {"/internal/nemotron/v1/models"},
                })
                local models = {}
                for _, res in ipairs({res1, res2}) do
                    if res.status == 200 then
                        local ok, data = pcall(cjson.decode, res.body)
                        if ok and data.data then
                            for _, m in ipairs(data.data) do
                                models[#models + 1] = m
                            end
                        end
                    end
                end
                ngx.header["Content-Type"] = "application/json"
                ngx.say(cjson.encode({object = "list", data = models}))
            }
        }

        # --- /v1/* API: リクエストボディの model フィールドでルーティング ---

        location /v1/ {
            set $backend "";

            access_by_lua_block {
                local cjson = require "cjson"
                ngx.req.read_body()
                local body = ngx.req.get_body_data()

                if not body or body == "" then
                    ngx.var.backend = "trtllm-multi-qwen"
                    return
                end

                local ok, data = pcall(cjson.decode, body)
                if not ok or not data.model then
                    ngx.var.backend = "trtllm-multi-qwen"
                    return
                end

                local model = string.lower(data.model)
                if string.find(model, "qwen", 1, true) then
                    ngx.var.backend = "trtllm-multi-qwen"
                elseif string.find(model, "nemotron", 1, true) then
                    ngx.var.backend = "trtllm-multi-nemotron"
                else
                    ngx.status = 404
                    ngx.header["Content-Type"] = "application/json"
                    ngx.say(cjson.encode({
                        error = {
                            message = "unknown model: " .. data.model,
                            type = "invalid_request_error",
                        }
                    }))
                    return ngx.exit(404)
                end
            }

            proxy_pass http://$backend:8000;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header Connection '';
            chunked_transfer_encoding off;
        }
    }
}
